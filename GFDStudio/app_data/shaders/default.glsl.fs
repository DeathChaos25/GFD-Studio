 #version 330 core

// thanks dniwetamp

// in
in vec3 fPosition;
in vec3 fNormal;
in vec3 fFacingNormal;
in vec2 fTex0;
in vec4 fColor0;

// out
out vec4 oColor;

// samplers
uniform sampler2D uDiffuse;
uniform sampler2D uSpecular;
uniform sampler2D uReflection;
uniform sampler2D uShadow;

// material properties
uniform int uMatFlags;
uniform vec4 uMatAmbient;
uniform vec4 uMatDiffuse;
uniform vec4 uMatEmissive;
uniform float uMatReflectivity;
uniform int DrawMethod;
uniform int alphaClip;
uniform bool uMatHasType0;
uniform bool uMatHasType1;
uniform bool uMatHasType4;
uniform int uMatType0Flags;

uniform vec4 uMatToonLightColor;
uniform float uMatToonLightThreshold;
uniform float uMatToonLightFactor;
uniform float uMatToonShadowBrightness;
uniform float uMatToonShadowThreshold;
uniform float uMatToonShadowFactor;

// material flags
const int cMF_OpaqueAlpha1   = 1 << 5;
const int cMF_OpaqueAlpha2   = 1 << 13;
const int cMF_EnableLight2   = 1 << 11;
const int cMF_HasDiffuseMap  = 1 << 20;
const int cMF_HasSpecularMap = 1 << 22;
const int cMF_HasReflectionMap = 1 << 23;
const int cMF_HasShadowMap   = 1 << 28;


float mapRange(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

float RGBAtoGray(vec4 RGBA) {
    return (RGBA.r+RGBA.g+RGBA.b)/3.0;
}

bool hasBitFlag(int bitField, int bitFlag){
    return ((bitField & bitFlag) != 0);
}

bool hasMatFlag(int bitFlag){
    return ((uMatFlags & bitFlag) != 0);
}

vec4 DefaultShader(vec4 diffuseColor, vec4 specularColor, vec4 reflectionColor, vec4 shadowColor)
{
    /* ---Brief explanation, generated by ChatGPT because I was too lazy to write everything down---
    1. It defines a constant light direction.
    2. It calculates a basic phong shadow using normals and the light direction.
    3. It checks a material flag to possibly set the shadow to full brightness.
    4. It calculates the color of the Phong shadow by blending the shadow with the ambient material color.
    5. It calculates the Phong specular reflection based on the light direction, normal, and position.
    6. It initializes an accumulated color as the diffuse color.
    7. Depending on certain material flags, it adds specular and reflection contributions to this accumulated color.
    8. Finally, it applies the Phong shadow color to this accumulated color and returns it.
    */

    const vec3 lightDirection = normalize(vec3( 10.0, 45.0, 10.0 ));
    //  basic shadow using normals
    float phongShadow = dot(lightDirection, fFacingNormal);
    float clampedPhongShadow = clamp(phongShadow, 0.0, 1.0);
    if (!hasMatFlag(cMF_EnableLight2))
        clampedPhongShadow = 1.0;
    vec3 phongShadowCol = clamp((vec3(clampedPhongShadow, clampedPhongShadow, clampedPhongShadow) * (1.0 - shadowColor.rrr) + uMatAmbient.rgb), 0, 1);
    // Phong specular
    vec3 refAngle = reflect(-lightDirection, fFacingNormal);
    float specAngle = max(dot(refAngle, normalize(-fPosition)), 0.0);
    vec3 specular = vec3(0.0);
    if ( uMatEmissive.a > 0.0 )
        specular = vec3(pow(specAngle, uMatEmissive.a));
    vec4 accumulatedColor = diffuseColor;
    accumulatedColor.a *= uMatDiffuse.a;
    if (hasMatFlag(cMF_HasSpecularMap) && hasMatFlag(cMF_HasReflectionMap)){
        accumulatedColor.rgb += uMatEmissive.rgb * specular.rgb * specularColor.rgb;
        accumulatedColor.rgb += specularColor.r * reflectionColor.rgb * uMatReflectivity;
    }
    else{
        accumulatedColor.rgb += uMatEmissive.rgb * specular.rgb * specularColor.rgb;
        accumulatedColor.rgb += reflectionColor.rgb * uMatReflectivity;
    }
    accumulatedColor.rgb *= phongShadowCol;
    return accumulatedColor;
}

vec4 CharacterShader(vec4 diffuseColor, vec4 specularColor, vec4 reflectionColor, vec4 shadowColor)
{
    /* ---Brief explanation, generated by ChatGPT because I was too lazy to write everything down---
    1. It defines a constant light direction and normalizes the eye position.
    2. It calculates a basic phong shadow using normals and the light direction, and clamps it.
    3. It calculates a toon shadow by ramping the unclamped shadow and checks a material flag to possibly set the toon shadow to full brightness.
    4. It applies the shadow map to the toon shadow
    5. It calculates rim light based on the facing normal, eye position, and basic shadow.
    6. It calculates Phong specular reflection based on the light direction, normal, and position.
    7. It colorizes the toon shadow using ambient color values.
    8. It initializes an accumulated color as the diffuse color.
    9. Depending on certain material flags, it adds specular and reflection contributions to this accumulated color.
    10. It mixes the accumulated color with a toon light color based on rim light alpha and shadow map alpha.
    11. It adds a toon shadow to the accumulated color based on a brightness factor.
    12. Finally, it returns the accumulated color.
    */
    vec3 toonShadowCol = (1.0 - shadowColor.rrr);
    const vec3 lightDirection = normalize(vec3( 90.0, 45.0, 90.0 ));
    vec3 eyePos = normalize( -fPosition );
    //  basic shadow using normals
    float phongShadow = dot(lightDirection, fFacingNormal);
    float clampedPhongShadow = clamp(phongShadow, 0.0, 1.0);
    // Ramp the shadow, copypasted from p5r shader
    float toonShadow = clamp((max(clampedPhongShadow - pow(uMatToonShadowThreshold, 1.8), 0.0) * uMatToonShadowFactor), 0, 1);
    if (!hasMatFlag(cMF_EnableLight2)){
        toonShadow = 1.0;
    }
    if (uMatType0Flags != 77) // disable shadows for face material
        toonShadowCol.rgb *= vec3(toonShadow);
    // Calculate rim light, copypasted from p5r shader
    float baseRimLight = clamp(( dot( fFacingNormal, mix( eyePos, fFacingNormal, -min( phongShadow, 0.0) ) )), 0.0, 1.0);
    float rampedRimLight = pow(( min( 1.0 - baseRimLight, uMatToonLightThreshold) / uMatToonLightThreshold), uMatToonLightFactor);
    // Phong Specular
    vec3 refAngle = reflect(-lightDirection, fFacingNormal);
    float specAngle = max(dot(refAngle, normalize(-fPosition)), 0.0);
    vec3 specular = vec3(0.0);
    if ( uMatEmissive.a > 0.0 )
        specular = vec3(pow(specAngle, uMatEmissive.a));
    //colorize toon shadow, using ambient color values
    toonShadowCol.rgb = clamp((toonShadowCol.rgb + uMatAmbient.rgb), 0, 1);
    //Calculate accumated color so far
    vec4 accumulatedColor = diffuseColor;
    accumulatedColor.a *= uMatDiffuse.a;
    if (hasMatFlag(cMF_HasSpecularMap) && hasMatFlag(cMF_HasReflectionMap)){
        accumulatedColor.rgb += uMatEmissive.rgb * specular.rgb * specularColor.rgb;
        accumulatedColor.rgb += specularColor.r * reflectionColor.rgb * uMatReflectivity;
    }
    else {
        accumulatedColor.rgb += uMatEmissive.rgb * specular.rgb * specularColor.rgb;
        accumulatedColor.rgb += reflectionColor.rgb * uMatReflectivity;
    }
    accumulatedColor.rgb = mix(accumulatedColor.rgb, uMatToonLightColor.rgb, rampedRimLight * uMatToonLightColor.a * shadowColor.a );
    vec3 addedShadow = accumulatedColor.rgb * toonShadowCol;
    accumulatedColor.rgb = mix(accumulatedColor.rgb, addedShadow, 1.0 - clamp(uMatToonShadowBrightness, 0, 1));
    return accumulatedColor;
}

vec4 PersonaShader(vec4 diffuseColor, vec4 specularColor, vec4 reflectionColor, vec4 shadowColor)
{
    /* ---Brief explanation, generated by ChatGPT because I was too lazy to write everything down---
    1.It defines a shadow map texture and a constant light direction, and normalizes the eye position.
    2. It calculates a basic shadow (Phong shadow) using normals and the light direction.
    3. It calculates rim light based on the facing normal, eye position, and basic shadow.
    4. It calculates Phong specular reflection based on the light direction, normal, and position.
    5. It colorizes the shadow map using ambient color values.
    6. It initializes an accumulated color as the diffuse color.
    7. Depending on certain material flags, it adds specular and reflection contributions to this accumulated color.
    8. It applies the shadow map to the accumulated color.
    9. It mixes the accumulated color with a toon light color based on rim light, toon light color alpha, and diffuse color alpha.
    10. Finally, it returns the accumulated color.
    */
    vec3 toonShadow = 1.0 - shadowColor.rrr;
    const vec3 lightDirection = normalize(vec3( 10.0, 45.0, 10.0 ));
    vec3 eyePos = normalize( -fPosition );
    float phongShadow = dot(lightDirection,fFacingNormal);
    // Calculate rim light, copypasted from p5r shader
    float baseRimLight = clamp(( dot( fFacingNormal, mix( eyePos, fFacingNormal, -min( phongShadow, 0.0) ) )), 0.0, 1.0);
    float rampedRimLight = pow(( min( 1.0 - baseRimLight, uMatToonLightThreshold) / uMatToonLightThreshold), uMatToonLightFactor);
    // Phong Specular
    vec3 refAngle = reflect(-lightDirection, fFacingNormal);
    float specAngle = max(dot(refAngle, normalize(-fPosition)), 0.0);
    vec3 specular = vec3(0.0);
    if ( uMatEmissive.a > 0.0 )
        specular = vec3(pow(specAngle, uMatEmissive.a));
    //colorize toon shadow, using ambient color values
    toonShadow.rgb = clamp((toonShadow.rgb + uMatAmbient.rgb), 0, 1);
    //Calculate accumated color so far
    vec4 accumulatedColor = diffuseColor;
    accumulatedColor.a *= uMatDiffuse.a;
    if (hasMatFlag(cMF_HasSpecularMap) && hasMatFlag(cMF_HasReflectionMap)){
        accumulatedColor.rgb += uMatEmissive.rgb * specular.rgb * specularColor.rgb;
        accumulatedColor.rgb += specularColor.r * reflectionColor.rgb * uMatReflectivity;
    }
    else{
        accumulatedColor.rgb += uMatEmissive.rgb * specular.rgb * specularColor.rgb;
        accumulatedColor.rgb += reflectionColor.rgb * uMatReflectivity;
    }
    accumulatedColor.rgb *= toonShadow.rgb;
    accumulatedColor.rgb = mix(accumulatedColor.rgb, uMatToonLightColor.rgb, rampedRimLight * uMatToonLightColor.a * diffuseColor.a );
    return accumulatedColor;
}

void main()
{
    /* ---Brief explanation, generated by ChatGPT because I was too lazy to write everything down---
    This function sets up texture maps, selects a shader to use based on material type flags, adjusts transparency 
    based on draw method and material flags, and outputs the final color of a fragment.
    1. It initializes diffuse, specular, reflection, shadow, and result colors, and normalized eye position.
    2. It calculates a reflection coordinate based on the eye position and facing normal.
    3. It sets up texture maps for diffuse, specular, reflection, and shadow maps using the mix function for optimization.
    4. It selects the shader to use (DefaultShader, CharacterShader, or PersonaShader) based on material type flags and mixes the result color accordingly.
    5. It adjusts the alpha component of the result color based on the draw method.
    6. Depending on the draw method and material type flags, it discards fragments based on their alpha value to implement clip transparency.
    7. If certain material flags are set, it discards fragments based on their alpha value compared to a threshold (alphaClip / 256.0) (alphaClip is Field90 in GMD).
    8. Finally, it assigns the result color to oColor.
    */

    vec4 diffuseColor = uMatDiffuse;
    vec4 specularColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec4 reflectionColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec4 shadowColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec4 resultColor = vec4(1.0);
    vec3 eyePos = normalize( -fPosition );
    vec3 reflectionCoord = reflect( eyePos, fFacingNormal);
    // setting up texture maps, using mix is more optimized than if/else statements apparently
    diffuseColor = mix(diffuseColor, texture(uDiffuse, fTex0), hasMatFlag(cMF_HasDiffuseMap));
    specularColor = mix(specularColor, texture(uSpecular, fTex0), hasMatFlag(cMF_HasSpecularMap));
    reflectionColor = mix(reflectionColor, texture(uReflection, reflectionCoord.xy), bool(hasMatFlag(cMF_HasReflectionMap) && DrawMethod != 2));
    shadowColor = mix(shadowColor, texture(uShadow, fTex0), hasMatFlag(cMF_HasShadowMap));
    // selecting the shader, again, using mix instead of if/else statements
    resultColor = mix(DefaultShader(diffuseColor, specularColor, reflectionColor, shadowColor), CharacterShader(diffuseColor, specularColor, reflectionColor, shadowColor), uMatHasType0);
    resultColor = mix(resultColor, PersonaShader(diffuseColor, specularColor, reflectionColor, shadowColor), bool(uMatHasType1 || uMatHasType4));

    resultColor.a *= mix(1.0, resultColor.r, bool(DrawMethod == 2));

    if (DrawMethod == 1 || DrawMethod == 2 ){ // can add proper alpha blending in the future maybe
        if ( resultColor.a < 0.2 )
            discard;
    }
    if (!uMatHasType1 && !uMatHasType4){
        if (DrawMethod == 0)
            if ( resultColor.a < 0.01 )
                discard;
    }

    if (hasMatFlag(cMF_OpaqueAlpha1) && hasMatFlag(cMF_OpaqueAlpha2)){
        if ( resultColor.a < alphaClip / 256.0 )
            discard;
    }
    oColor = resultColor;
}